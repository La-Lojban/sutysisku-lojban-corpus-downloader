// //downloads a propbank dump and converts it to sutysisku's dexie-like format

// import { XMLParser } from 'fast-xml-parser';
// import axios from 'axios';

// import * as fs from 'fs';
// import * as path from 'path';

// const extract = require('extract-zip');

// import * as stream from 'stream';
// import { promisify } from 'util';

// const finished = promisify(stream.finished);

// interface DictExample {
//   text: string;
//   annotation: string;
//   comment: string;
// }

// interface DictEntry {
//   w: string;
//   d: string;
//   n: string;
//   subtitle: string;
//   s: string;
//   id: string;
//   e: DictExample[];
// }

// function arrayify(arg: any) {
//   if (Array.isArray(arg)) return arg ?? [];
//   if (typeof arg === 'undefined') return [];
//   return [arg];
// }

// function incSlot(slot: string) {
//   if (!isNaN(Number(slot))) return parseInt(slot) + 1;
//   return slot;
// }

// function replaceArg(text = '', digitWords = false) {
//   let output = text.replace(/\barg([0-9]+)\b/gi, (_match: string, p1: string) => {
//     return `$x_${incSlot(p1)}$`;
//   });
//   if (digitWords)
//     output = output.replace(/\b([0-9]+)\b/gi, (_match: string, p1: string) => {
//       return `$x_${incSlot(p1)}$`;
//     });
//   return output;
// }

// export async function downloadFile(fileUrl: string, outputLocationPath: string): Promise<any> {
//   const writer = fs.createWriteStream(outputLocationPath);
//   return axios({
//     method: 'get',
//     url: fileUrl,
//     responseType: 'stream',
//   }).then((response) => {
//     response.data.pipe(writer);
//     return finished(writer); //this is a Promise
//   });
// }

// async function download({ tmpDir, url }: { tmpDir: string; url: string }): Promise<{ [key: string]: DictEntry }> {
//   const parser = new XMLParser({
//     attributeNamePrefix: '',
//     attributesGroupName: '#attributes',
//     ignoreAttributes: false,
//     allowBooleanAttributes: true,
//     parseAttributeValue: false,
//   });

//   const propbankZip = path.join(tmpDir, 'propbank.zip');
//   const propbankPath = path.join(tmpDir, 'propbank');
//   const propbankPathFrames = path.join(tmpDir, 'propbank', 'propbank-frames-main', 'frames');
//   await downloadFile(url, propbankZip);
//   await extract(propbankZip, { dir: propbankPath });

//   const dictionaryEntries: { [key: string]: DictEntry } = {};

//   const frames = fs.readdirSync(propbankPathFrames);

//   frames.forEach((file: string) => {
//     const data = fs.readFileSync(path.join(propbankPathFrames, file));
//     const json = parser.parse(data);

//     arrayify(json?.frameset).forEach(({ predicate }: { predicate: any }) => {
//       arrayify(predicate?.roleset).forEach((entry: any) => {
//         const id = entry?.['#attributes']?.id;
//         const dictEntry: DictEntry = {
//           id,
//           n: entry?.['#attributes']?.name,
//           subtitle: entry?.aliases?.alias?.['#attributes']?.framenet,
//           s: entry?.aliases?.alias?.['#attributes']?.pos,
//           w: entry?.aliases?.alias?.['#text'],
//           d: arrayify(entry?.roles?.role)
//             .map((slot: any) => `$x_${incSlot(slot?.['#attributes']?.n)}$: ${replaceArg(slot?.['#attributes']?.descr)}`)
//             .join('; '),
//           e: arrayify(entry?.example).map((example: any) => {
//             return {
//               text: example.text,
//               comment: replaceArg(example?.['#attributes']?.name, true),
//               annotation: arrayify(example?.arg)
//                 .map((annotation: any) => {
//                   return `$x_${incSlot(annotation?.['#attributes']?.n)}$: ${annotation?.['#text']}`;
//                 })
//                 .join('; '),
//             };
//           }),
//         };
//         dictionaryEntries[id] = dictEntry;
//       });
//     });
//   });
//   return dictionaryEntries;
// }

// export async function saveDump({
//   outputDir = path.join(__dirname, '../dist'),
//   tmpDir = path.join(__dirname, '../tmp'),
//   url = 'https://github.com/propbank/propbank-frames/archive/refs/heads/main.zip',
// }) {
//   fs.mkdirSync(outputDir, { recursive: true });
//   fs.mkdirSync(tmpDir, { recursive: true });
//   const dictionaryEntries = await download({ tmpDir, url });
//   fs.rmSync(tmpDir, { recursive: true, force: true });
//   fs.writeFileSync(path.join(outputDir, 'propbank.json'), JSON.stringify(dictionaryEntries, null, '\t'));
// }
